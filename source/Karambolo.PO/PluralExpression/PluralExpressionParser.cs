/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 3.1.0.0
 */
using Hime.Redist;
using Hime.Redist.Parsers;

namespace Karambolo.PO.PluralExpression
{
    /// <summary>
    /// Represents a parser
    /// </summary>
    sealed class PluralExpressionParser : LRkParser
	{
		/// <summary>
		/// The automaton for this parser
		/// </summary>
		private static readonly LRkAutomaton commonAutomaton = LRkAutomaton.Find(typeof(PluralExpressionParser), "PluralExpressionParser.bin");
		/// <summary>
		/// Contains the constant IDs for the variables and virtuals in this parser
		/// </summary>
		internal class ID
		{
			/// <summary>
			/// The unique identifier for variable expression
			/// </summary>
			public const int expression = 0x0007;
			/// <summary>
			/// The unique identifier for variable logical_or_expression
			/// </summary>
			public const int logical_or_expression = 0x0008;
			/// <summary>
			/// The unique identifier for variable logical_and_expression
			/// </summary>
			public const int logical_and_expression = 0x0009;
			/// <summary>
			/// The unique identifier for variable equality_expression
			/// </summary>
			public const int equality_expression = 0x000A;
			/// <summary>
			/// The unique identifier for variable relational_expression
			/// </summary>
			public const int relational_expression = 0x000B;
			/// <summary>
			/// The unique identifier for variable additive_expression
			/// </summary>
			public const int additive_expression = 0x000C;
			/// <summary>
			/// The unique identifier for variable multiplicative_expression
			/// </summary>
			public const int multiplicative_expression = 0x000D;
			/// <summary>
			/// The unique identifier for variable factor
			/// </summary>
			public const int factor = 0x000E;
			/// <summary>
			/// The unique identifier for variable __axiom
			/// </summary>
			public const int __axiom = 0x0020;
		}
		/// <summary>
		/// The collection of variables matched by this parser
		/// </summary>
		/// <remarks>
		/// The variables are in an order consistent with the automaton,
		/// so that variable indices in the automaton can be used to retrieve the variables in this table
		/// </remarks>
		private static readonly Symbol[] variables = {
			new Symbol(0x0007, "expression"), 
			new Symbol(0x0008, "logical_or_expression"), 
			new Symbol(0x0009, "logical_and_expression"), 
			new Symbol(0x000A, "equality_expression"), 
			new Symbol(0x000B, "relational_expression"), 
			new Symbol(0x000C, "additive_expression"), 
			new Symbol(0x000D, "multiplicative_expression"), 
			new Symbol(0x000E, "factor"), 
			new Symbol(0x0020, "__axiom") };
		/// <summary>
		/// The collection of virtuals matched by this parser
		/// </summary>
		/// <remarks>
		/// The virtuals are in an order consistent with the automaton,
		/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
		/// </remarks>
		private static readonly Symbol[] virtuals = {
 };
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		public PluralExpressionParser(PluralExpressionLexer lexer) : base (commonAutomaton, variables, virtuals, null, lexer) { }
	}
}
